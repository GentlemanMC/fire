package dev.zprestige.fire.module.exploit.phase

import dev.zprestige.fire.event.bus.EventListener
import dev.zprestige.fire.module.Descriptor
import dev.zprestige.fire.module.Module
import dev.zprestige.fire.settings.impl.Slider
import dev.zprestige.fire.settings.impl.Switch
import io.netty.util.internal.ConcurrentSet
import net.minecraft.network.play.client.CPacketConfirmTeleport
import net.minecraft.network.play.client.CPacketPlayer
import net.minecraft.util.math.Vec3d
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ThreadLocalRandom

@Descriptor(description = "Allows flying through blocks")
class Phase : Module() {
    val factor: Slider = Menu.Slider("Factor", 1f, 0.5f, 10f)
    val antiKick: Switch = Menu.Switch("AntiKick", true)
    var packets = 0
    var teleportId = 0
    val rubberbandMap: MutableMap<Int, TimeVec3d> = ConcurrentHashMap()
    val cPacketPlayerSet: MutableSet<CPacketPlayer> = ConcurrentSet()

    init {
        eventListeners = arrayOf<EventListener<*, *>>(
            MoveListener(this),
            PacketReceiveListener(this),
            PacketSendListener(this),
            TickListener(this)
        )
    }

    override fun onEnable() {
        packets = 0
        teleportId = 0
        cPacketPlayerSet.clear()
        rubberbandMap.clear()
    }

    fun checkPackets(max: Int): Boolean {
        if (packets++ >= max) {
            packets = 0
            return true
        }
        return false
    }

    fun sendPackets(x: Double, y: Double, z: Double, teleport: Boolean) {
        val vec3d = Vec3d(x, y, z)
        val secondVec = mc.player.positionVector.add(vec3d)
        val currentNextInt = ThreadLocalRandom.current().nextInt(29000000)
        val thirdVec = secondVec.addVector(vec3d.x,
            if (ThreadLocalRandom.current().nextBoolean()) currentNextInt.toDouble() else -currentNextInt.toDouble(),
            vec3d.z
        )
        sendPlayerPacket(CPacketPlayer.Position(secondVec.x, secondVec.y, secondVec.z, mc.player.onGround))
        sendPlayerPacket(CPacketPlayer.Position(thirdVec.x, thirdVec.y, thirdVec.z, mc.player.onGround))
        if (teleport) {
            teleportId++
            rubberbandMap[teleportId] = TimeVec3d(secondVec.x, secondVec.y, secondVec.z, System.currentTimeMillis())
            mc.player.connection.sendPacket(CPacketConfirmTeleport(teleportId))
        }
    }

    private fun sendPlayerPacket(cPacketPlayer: CPacketPlayer) {
        cPacketPlayerSet.add(cPacketPlayer)
        mc.player.connection.sendPacket(cPacketPlayer)
    }

    class TimeVec3d(x: Double, y: Double, z: Double, val time: Long) : Vec3d(x, y, z)
}