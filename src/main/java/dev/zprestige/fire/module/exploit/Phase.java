package dev.zprestige.fire.module.exploit;

import dev.zprestige.fire.events.eventbus.annotation.RegisterListener;
import dev.zprestige.fire.events.impl.MoveEvent;
import dev.zprestige.fire.events.impl.PacketEvent;
import dev.zprestige.fire.events.impl.TickEvent;
import dev.zprestige.fire.module.Descriptor;
import dev.zprestige.fire.module.Module;
import dev.zprestige.fire.settings.impl.Slider;
import dev.zprestige.fire.settings.impl.Switch;
import dev.zprestige.fire.util.impl.EntityUtil;
import io.netty.util.internal.ConcurrentSet;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

@Descriptor(description = "Allows flying through blocks")
public class Phase extends Module {
    public final Slider factor = Menu.Slider("Factor", 1f, 0.5f, 10f);
    public final Switch antiKick = Menu.Switch("AntiKick", true);
    protected int packets = 0, teleportId = 0;
    protected final Map<Integer, TimeVec3d> rubberbandMap = new ConcurrentHashMap<>();
    protected final Set<CPacketPlayer> cPacketPlayerSet = new ConcurrentSet<>();

    @RegisterListener
    public void onTick(final TickEvent event) {
        if (mc.player == null || mc.world == null) {
            disableModule();
            return;
        }
        rubberbandMap.entrySet().removeIf(entry -> System.currentTimeMillis() - entry.getValue().getTime() > TimeUnit.SECONDS.toMillis(30L));
        double motionY;
        mc.player.motionZ = 0.0;
        mc.player.motionY = 0.0;
        mc.player.motionX = 0.0;
        if (teleportId == 0) {
            if (checkPackets(4)) {
                sendPackets(0.0, 0.0, 0.0, false);
            }
            return;
        }
        final boolean phase = !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox()).isEmpty();
        if (mc.player.movementInput.jump && (phase || !EntityUtil.isMoving())) {
            motionY = antiKick.GetSwitch() && !phase && checkPackets(20) ? -0.032 : 0.062;
        } else {
            motionY = mc.player.movementInput.sneak ? -0.062 : !phase ? (checkPackets(4) ? (antiKick.GetSwitch() ? -0.04 : 0.0) : 0.0) : 0.0;
        }
        if (phase && EntityUtil.isMoving() && motionY != 0.0) {
            motionY /= 2.5f;
        }
        final float[] dirSpeed = EntityUtil.getSpeed(phase ? 0.031 : 0.26);
        int factorInt = (int) Math.floor(factor.GetSlider());
        if (Math.random() <= factor.GetSlider() - factorInt) {
            factorInt++;
        }
        for (int i = 1; i <= factorInt; ++i) {
            sendPackets(mc.player.motionX = dirSpeed[0] * i, mc.player.motionY = motionY * i, mc.player.motionZ = dirSpeed[1] * i, true);
        }
    }


    @Override
    public void onEnable() {
        packets = 0;
        teleportId = 0;
        cPacketPlayerSet.clear();
        rubberbandMap.clear();
    }

    @RegisterListener
    public void onMove(final MoveEvent event) {
        if (teleportId != 0) {
            event.setMotion(mc.player.motionX, mc.player.motionY, mc.player.motionZ);
        }
        if (!mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox()).isEmpty()) {
            mc.player.noClip = true;
        }
    }

    @RegisterListener
    public void onPacketSend(final PacketEvent.PacketSendEvent event) {
        if (event.getPacket() instanceof CPacketPlayer) {
            final CPacketPlayer packet = (CPacketPlayer) event.getPacket();
            if (cPacketPlayerSet.contains(packet)) {
                cPacketPlayerSet.remove(packet);
                return;
            }
            event.setCancelled(true);
        }
    }

    @RegisterListener
    public void onPacketReceive(final PacketEvent.PacketReceiveEvent event) {
        if (event.getPacket() instanceof SPacketPlayerPosLook) {
            final SPacketPlayerPosLook packet = (SPacketPlayerPosLook) event.getPacket();
            final TimeVec3d posVec = rubberbandMap.remove(packet.getTeleportId());
            if (mc.world.isBlockLoaded(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ), false) && !(mc.currentScreen instanceof GuiDownloadTerrain) && posVec != null && posVec.x == packet.getX() && posVec.y == packet.getY() && posVec.z == packet.getZ()) {
                event.setCancelled(true);
                return;
            }
            packet.yaw = mc.player.rotationYaw;
            packet.pitch = mc.player.rotationPitch;
            teleportId = packet.getTeleportId();
        }
    }

    protected boolean checkPackets(final int max) {
        if (packets++ >= max) {
            packets = 0;
            return true;
        }
        return false;
    }

    protected void sendPackets(double x, double y, double z, boolean teleport) {
        final Vec3d vec3d = new Vec3d(x, y, z);
        final Vec3d secondVec = mc.player.getPositionVector().add(vec3d);
        final int currentNextInt = ThreadLocalRandom.current().nextInt(29000000);
        final Vec3d thirdVec = secondVec.addVector(vec3d.x, ThreadLocalRandom.current().nextBoolean() ? currentNextInt : -currentNextInt, vec3d.z);
        sendPlayerPacket(new CPacketPlayer.Position(secondVec.x, secondVec.y, secondVec.z, mc.player.onGround));
        sendPlayerPacket(new CPacketPlayer.Position(thirdVec.x, thirdVec.y, thirdVec.z, mc.player.onGround));
        if (teleport) {
            teleportId++;
            rubberbandMap.put(teleportId, new TimeVec3d(secondVec.x, secondVec.y, secondVec.z, System.currentTimeMillis()));
            mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportId));
        }
    }

    protected void sendPlayerPacket(CPacketPlayer cPacketPlayer) {
        cPacketPlayerSet.add(cPacketPlayer);
        mc.player.connection.sendPacket(cPacketPlayer);
    }


    protected static class TimeVec3d extends Vec3d {
        protected final long time;

        public TimeVec3d(double x, double y, double z, long time) {
            super(x, y, z);
            this.time = time;
        }

        public long getTime() {
            return time;
        }
    }
}
