package dev.zprestige.fire.module.exploit.choruspredict

import dev.zprestige.fire.Main
import dev.zprestige.fire.event.bus.EventListener
import dev.zprestige.fire.event.impl.ChorusEvent
import dev.zprestige.fire.manager.playermanager.PlayerManager
import dev.zprestige.fire.util.impl.BlockUtil
import net.minecraft.util.math.Vec3d

class ChorusListener(chorusPredict: ChorusPredict) : EventListener<ChorusEvent, ChorusPredict>(
    ChorusEvent::class.java, chorusPredict
) {
    override fun invoke(e: Any) {
        val event = e as ChorusEvent
        module.chorusMap[Vec3d(event.x, event.y, event.z)] = System.currentTimeMillis()
        if (module.rotate.GetSwitch() && (BlockUtil.isPlayerSafe(PlayerManager.Player(mc.player)) || !module.onlyWhileSafe.GetSwitch())) {
            val min = Vec3d(event.x, event.y, event.z)
            val bb = mc.player.entityBoundingBox
            val size = Vec3d(bb.maxX - bb.minX, bb.maxY - bb.minY, bb.maxZ - bb.minZ)
            if (module.rotate.GetSwitch() && (BlockUtil.isPlayerSafe(PlayerManager.Player(mc.player)) || !module.onlyWhileSafe.GetSwitch())) {
                val rots = Main.rotationManager.calculateAngle(Vec3d(min.x + size.x / 2f,
                    min.y + size.y / 2f,
                    min.z + size.z / 2f
                )
                )
                mc.player.rotationYaw = rots[0]
                mc.player.rotationPitch = rots[1]
            }
        }
    }
}